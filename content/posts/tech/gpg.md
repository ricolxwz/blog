---
title: 简单了解GPG
date: 2024-09-22T21:45:51+10:00
author: 麦旋风超好吃
avatar: https://cdn.jsdelivr.net/gh/sigmax0124/logo@master/favicon-avatar.jpg
authorlink: https://ricolxwz.de
cover: /img/aeed6199d8cf0e7803fe2542fd64a33b.webp
images:
  - /img/aeed6199d8cf0e7803fe2542fd64a33b.webp
categories:
  - 科技
tags:
  - GPG
  - 加密
nolastmod: true
showPrevNext: false
showTableOfContents: true
showCover: false
---

GPG, 或称GNUPG, 是一个GNU项目, 它是openPGP标准的实现.

<!--more-->

它的起源是由程序员Phil Zimmermann为了避开政府监视开发的加密软件PGP. 但是, 它是商业软件, 不能自由, 免费的使用. 所以自由软件基金会决定, 开发一个PGP的替代品, GNUPG, 这就是GPG. GPG既可以用于加密数据, 又可以用于签名, 或者两者混用也可以. 

## "公钥加密", "私钥签名"

这里我们要弄清楚一个概念, 即"公钥加密, 私钥签名". "公钥加密"指的是发送者使用接受者的公钥加密消息, 只有接受者能够使用自己的私钥解密消息, 相当于接受者给你了一个加密的信道, 让你传输. "私钥签名"指的是发送者使用子集的私钥签名一段数据, 任何接受者都可以用发送者的公钥来验证签名.

"公钥签名", 如SSH, 当用户使用SSH连接服务器的时候, 客户端会发送它想使用的公钥的标识信息, 这个标识信息是公钥的一部分, 包含了公钥的类型和简短的标识符. 服务器在接收到连接请求后, 会在`authorized_keys`文件中查找公钥, 根据标识符找到后, 服务器会生成一个随机数, 也叫作挑战信息, 使用公钥对这个随机数进行加密, 并将加密后的挑战信息发给客户端, 客户端收到服务器发来的加密挑战信息后, 使用私钥解密这个挑战信息, 客户端解密完成后, 将解密结果发送回服务器, 服务器收到解密的结果后, 验证结果是否正确, 如果客户端正确解密了挑战信息, 说明客户端确实拥有对应的私钥, 从而证明了身份. 当然, 为了防止MITM, 服务器会发送自己的公钥给客户端, 然后保存在客户端的`known_hosts`文件中, 此后连接时, 客户端会检查对方发来的公钥是否和合法服务器的公钥匹配, 若对方就是初始连接时候的服务器, 则认为连接可信, 继续连接.

"私钥签名", 主要用于证明数字来自签名者. 签名者(持有私钥的人)首先对消息的数据进行哈希运算, 生成一个固定长度的消息摘要, digest, 例如使用SHA-256, MD5加密算法. 然后使用私钥对生成的哈希值进行签名, 注意, 签名的是哈希值而不是整个消息本身. 签名者将消息和签名一起发送给接受者. 接受者(持有公钥的人)首先对数据使用相同的哈希运算, 生成消息的哈希值. 然后通过公钥来解密签名者附带的签名, 解密之后, 接受者将得到签名者当初加密的原始哈希值, 接受者将自己生成的哈希值与通过签名解密得到的哈希值进行比较, 如果两个哈希值相同, 证明消息没有被篡改; 如果不同, 则说明消息在传输过程中被篡改或签名无效. 细心的小伙伴被发现了, 有可能在发送公钥的过程中, 被MITM, 然后拿到的公钥实际上是其他发送者的公钥, 一般情况下会引入证书颁发机构, CA, 通过证书验证公钥的真实性. 签名者的公钥会被放入一个证书中, 这个证书由CA使用CA的私钥签署, 证书中包含签名者的公钥, 身份信息, 证书的有效期和和该证书的签名等信息. 接受者的浏览器/操作系统的受信任证书库中会预先包含CA的公钥, 接受者在接收到证书的时候, 会通过预先存好的证书库中的公钥检查证书是否合法(经过篡改), 若未经过篡改, 说明证书中包含的签名者的公钥是合法的, 然后使用签名者的公钥验证原始信息是否合法, 这就是"信任链", 信任链的顶部就是CA. 典型的例子如Https, 服务器会使用给自己的私钥签名之后, 附带本身的证书, 一起发送给客户端, 客户端会通过证书库验证证书的公钥是否是"受信任的根证书颁发机构"颁发的, 如果是, 则提取证书中的公钥, 验证网页是否被篡改. 在签名验证完沉过后, 客户端和服务器会协商生成一个对称加密密钥, 用于加密后续的通信数据, 从这个时刻开始, 双方通过对称加密开始通信, 确保数据的传输是加密的, 无法被窃听或者篡改. 所以, 我们向Let's Encrypt等机构申请的是证书, 证书中**包含**了签名者的私钥对应的公钥.

## 安装

这里我们在Archlinux上安装GPG:

```bash
sudo pacman -S gnupg
```

安装完毕后, 可以通过`gpg --help`查看命令, `gpg --version`查看版本.

## 生成密钥

生成密钥的命令主要有三个:

- `gpg --full-generate-key`
- `gpg --generate-key`
- `gpg --quick-generate-key`

其中, 后两个在加密算法, 密钥长度和有效期等选项的时候使用的是有效值, 而第一个则是由用户手动配置和管理的, 我们以第一个作为试验对象, 会弹出一些选项:

- 选择加密算法和用途